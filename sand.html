<html>
  <header></header>
  <body>
    <div style="background-color: black;">
      <canvas id="src" width="10" height="10"></canvas>
      <canvas id="dst" width="1" height="1"></canvas>
    </div>
    <select id="tool"> </select>
    <label id="">Pen:</label>
    <label id="penRadius">2</label>
    <button id="plus">+</button>
    <button id="minus">-</button>
    <script>
      console.log("starting sand.js");
      /*

      Ideas / TODO

      Hot air rises
      Soot Clouds

      Metal
      - solid / cant burn
      - gets hot? makes steam?

      Ice
      - melts due to fire next to it
      but doesnt catch
      - can freeze water
      - eventually melts

      */
      LIFETIME = 1000;
      AMBIENT_TEMP = 0.0; //22.22 is actual ambient
      function place_circle(x, y, r, m) {
        circle(x, y, r, (i, j) => {
          grid.place(i, j, m);
        });
      }

      function circle(x, y, r, cb) {
        let top = y - r;
        let bottom = y + r;
        for (var j = top; j <= bottom; j++) {
          let yd = j - y;
          let xd = Math.sqrt(r * r - yd * yd);
          let left = Math.ceil(x - xd);
          let right = Math.floor(x + xd);

          for (var i = left; i <= right; i++) {
            cb(i, j);
          }
        }
      }

      function clone(obj) {
        if (null == obj || "object" !== typeof obj) return obj;
        var copy = new obj.constructor();
        for (var attr in obj) {
          if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
        }
        return copy;
      }

      function getDesc(obj, prop) {
        var desc = Object.getOwnPropertyDescriptor(obj, prop);
        return (
          desc ||
          (obj = Object.getPrototypeOf(obj) ? getDesc(obj, prop) : void 0)
        );
      }
      function multiInherit(...protos) {
        return Object.create(
          new Proxy(Object.create(null), {
            has: (target, prop) => protos.some((obj) => prop in obj),
            get(target, prop, receiver) {
              var obj = protos.find((obj) => prop in obj);
              return obj ? Reflect.get(obj, prop, receiver) : void 0;
            },
            set(target, prop, value, receiver) {
              var obj = protos.find((obj) => prop in obj);
              return Reflect.set(
                obj || Object.create(null),
                prop,
                value,
                receiver
              );
            },
            *enumerate(target) {
              yield* this.ownKeys(target);
            },
            ownKeys(target) {
              var hash = Object.create(null);
              for (var obj of protos)
                for (var p in obj) if (!hash[p]) hash[p] = true;
              return Object.getOwnPropertyNames(hash);
            },
            getOwnPropertyDescriptor(target, prop) {
              var obj = protos.find((obj) => prop in obj);
              var desc = obj ? getDesc(obj, prop) : void 0;
              if (desc) desc.configurable = true;
              return desc;
            },
            preventExtensions: (target) => false,
            defineProperty: (target, prop, desc) => false
          })
        );
      }
      /////// /////// /////// /////// ///////
      ///////        End Utils
      /////// /////// /////// /////// ///////
    </script>
    <script>
      /////// /////// /////// /////// ///////
      ///////        Materials
      /////// /////// /////// /////// ///////
      var Material = {
        Empty: "Empty",
        Sand: "Sand",
        Water: "Water",
        Wood: "Wood",
        Cloud: "Cloud",
        Dirt: "Dirt",
        Smoke: "Smoke",
        Blackhole: "Blackhole",
        Fire: "Fire",
        Torch: "Torch",
        Oil: "Oil",
        Steam: "Steam",
        Ice: "Ice",
        Flea: "Flea"
      };

      function objOfType(material) {
        return eval("new " + material + "()");
      }

      function place_if_empty(x, y, m) {
        if (grid.empty(x, y)) {
          grid.place(x, y, m);
          return true;
        }
        return false;
      }

      class Element {
        constructor() {
          this.lifetime = 1000;
          this.density = 1;
          this.onfire = false;
          this.temperature = AMBIENT_TEMP;
        }
        update(x, y, dt) {}
        color() {
          return [255, 0, 255, 255]; // pink
        }

        is_flammable() {
          return false;
        }

        hot_liquid() {
          return Smoke;
        }

        updateTemperature(x, y, deltaMilliSeconds) {
          // Determine any heat sources or if ambient temp is higher or lower
          let averageTemp = AMBIENT_TEMP;
          let validTemps = 1;
          for (var i = 0; i < 8; i++) {
            if (grid.in(x + dx[i], y + dy[i])) {
              averageTemp += grid.at(x + dx[i], y + dy[i]).temperature;
              validTemps++;
            }
          }
          averageTemp /= validTemps;

          if (this.temperature < averageTemp) {
            this.temperature += 0.1;
          } else if (this.temperature > averageTemp) {
            this.temperature -= 0.1;
          }
        }

        update_flame(x, y, deltaMilliSeconds) {
          if (this.onfire) {
            this.lifetime -= deltaMilliSeconds;

            for (var i = 0; i < 8; i++) {
              if (place_if_empty(x + dx[i], y + dy[i], this.hot_liquid())) {
                break;
              }
            }

            // only burn if not our first update
            if (this.lifetime > 0.9 * LIFETIME) {
              return;
            }

            for (var i = 0; i < 8; i++) {
              if (grid.is_flammable(x + dx[i], y + dy[i])) {
                if (Math.random() > 0.9) {
                  grid.place(x + dx[i], y + dy[i], Fire);
                }
              }
            }
          }
        }
      }

      class Solid extends Element {
        constructor() {
          super();
          this.density = 2;
        }
      }

      class Gas extends Element {
        constructor() {
          super();
          this.density = 0;
        }

        // TODO: Determine if this is the cause of liquid going around gases.
        spread(x, y, deltaMilliSeconds) {
          if (this.heading == 0) {
            let spread = grid_w;
            let dir = Math.random() < 0.5;
            this.heading = dir ? spread : -spread;
          }
          this.heading--;

          // Check the tile in the direction we are heading
          let step = Math.sign(this.heading);
          // We hit a non empty tile, stop moving
          if (!grid.empty(x + step, y)) {
            this.heading = 0;
            return;
          }
          // its empty move there
          grid.swap(x, y, x + step, y);
        }

        gas_moves_through(x, y, deltaMilliSeconds) {
          let gasPlacementYIndex = y - 1;
          // Find the next non-cloud or non-fire tile vertically above
          while (
            //
            gasPlacementYIndex > 0 &&
            //
            (grid.matching(x, gasPlacementYIndex, Empty) ||
              grid.matching(x, gasPlacementYIndex, Cloud) ||
              grid.matching(x, gasPlacementYIndex, Fire))
            //
          ) {
            gasPlacementYIndex--;
          }

          if (
            grid.matching(x, gasPlacementYIndex, Empty) ||
            grid.matching(x, gasPlacementYIndex, Gas) ||
            grid.matching(x, gasPlacementYIndex, Cloud)
          ) {
            grid.clear(x, y);
            // TODO why are we placing Smoke?
            grid.place(x, gasPlacementYIndex, Smoke);
          }
        }

        update(x, y, deltaMilliSeconds) {
          this.lifetime -= deltaMilliSeconds;
          // Falling up
          if (grid.empty(x, y - 1)) {
            grid.swap(x, y, x, y - 1);
            // up side
          } else if (grid.empty(x - 1, y - 1)) {
            grid.swap(x, y, x - 1, y - 1);
          } else if (grid.empty(x + 1, y - 1)) {
            grid.swap(x, y, x + 1, y - 1);
          } else if (
            // if clouds or fire are above us...
            grid.matching(x, y - 1, Cloud) ||
            grid.matching(x, y - 1, Fire)
          ) {
            this.gas_moves_through(x, y, deltaMilliSeconds);
          } else {
            this.spread(x, y, deltaMilliSeconds);
          }
        } // End Update
      } // End Gas

      class Empty extends Gas {
        color() {
          return [0, 0, 0];
        }
      }

      class Liquid extends Element {
        constructor() {
          super();
          this.heading = 0;
          this.density = 1;
        }
        update(x, y, deltaMilliSeconds) {
          this.updated = true;
          if (grid.empty(x, y + 1)) {
            grid.swap(x, y, x, y + 1);
          } else if (grid.empty(x - 1, y + 1)) {
            grid.swap(x, y, x - 1, y + 1);
          } else if (grid.empty(x + 1, y + 1)) {
            grid.swap(x, y, x + 1, y + 1);
          } else if (grid.islessdense(x, y + 1, this.density)) {
            grid.swap(x, y, x, y + 1);
          } else if (grid.islessdense(x - 1, y + 1, this.density)) {
            grid.swap(x, y, x - 1, y + 1);
          } else if (grid.islessdense(x + 1, y + 1, this.density)) {
            grid.swap(x, y, x + 1, y + 1);
          } else {
            if (this.heading == 0) {
              let spread = grid_w;
              let dir = Math.random() < 0.5;
              this.heading = dir ? spread : -spread;
            }
            this.heading--;

            // Check the tile in the direction we are heading
            let step = Math.sign(this.heading);
            // We hit a non empty tile, stop moving
            if (!grid.islessdense(x + step, y, this.density)) {
              this.heading = 0;
              return;
            }
            // its empty move there
            grid.swap(x, y, x + step, y);
          }
        }
      }

      class Water extends Liquid {
        constructor() {
          super();
          this.density = 1.0;
          this.temperature = 2.0;
        }
        color() {
          return [0, 0, 250];
        }

        hot_liquid() {
          return Steam;
        }

        is_flammable() {
          return true;
        }

        update_flame(x, y, deltaMilliSeconds) {
          if (this.onfire) {
            this.lifetime -= 10 * deltaMilliSeconds;
          }
          if (this.lifetime < 1) {
            grid.place(x, y, Steam);
          }
        }

        update(x, y, deltaMilliSeconds) {
          super.update(x, y, deltaMilliSeconds);
          this.update_flame(x, y, deltaMilliSeconds);
        }
      }

      class Oil extends Liquid {
        constructor() {
          super();
          this.density = 0.89;
        }

        is_flammable() {
          return true;
        }

        update(x, y, deltaMilliSeconds) {
          super.update(x, y, deltaMilliSeconds);
          this.update_flame(x, y, deltaMilliSeconds);
        }

        color() {
          if (Math.random() < 0.03) {
            return [130, 130, 160, 155];
          } else if (Math.random() < 0.33) {
            return [30, 30, 60, 155];
          } else {
            return [10, 10, 20, 155];
          }
        }
      }

      class Blackhole extends Solid {
        update(x, y, deltaMilliSeconds) {
          var pullRange = 10;
          var pullRadius = pullRange / 2;
          for (var row = x - pullRadius; row <= x + pullRadius; row++) {
            for (var col = y + pullRadius; col >= y - pullRadius; col--) {
              if (!grid.in(row, col)) continue;
              let tile = grid.at(row, col);
              if (tile instanceof Empty) continue;
              if (tile instanceof Blackhole) continue;
              // Translate the tile in question towards the x,y

              // A positive dx will imply the tile moves right.
              let dx = 0;
              // A negative dy will imply the tile moves up.
              let dy = 0;

              // 1. Determine horizontal translation.
              // left of black hole
              if (row < x) {
                dx = 1;
              }
              // right of black hole
              else if (row > x) {
                dx = -1;
              }

              // 2. Determine vertical translation.
              // below black hole
              if (col > y) {
                dy = -1;
              }
              // above black hole
              else if (col < y) {
                dy = 1;
              }
              if (row + dx != x || col + dy != y) {
                let swappingTile = grid.at(row + dx, col + dy);
                if (swappingTile instanceof Blackhole) continue;
                if (Math.random() < 0.6) continue;
                grid.swap(row, col, row + dx, col + dy);
              }
            }
          }

          // n is the 8 neighbors around the black hole
          let n = [];
          for (var i = 0; i < 8; i++) {
            n.push([x + dx[i], y + dy[i]]);
            // clear all the ones around the black hole
            grid.clear(x + dx[i], y + dy[i]);
          }
        }
      }

      class Cloud extends Solid {
        color() {
          return [250, 250, 250];
        }
        update(x, y, deltaMilliSeconds) {
          if (Math.random() > 0.99) {
            let waterPlacementYIndex = y + 1;
            // Find the next non-cloud tile vertically below
            while (
              waterPlacementYIndex < grid_h &&
              grid.matching(x, waterPlacementYIndex, Cloud)
            ) {
              waterPlacementYIndex++;
            }
            if (
              grid.matching(x, waterPlacementYIndex, Empty) ||
              grid.matching(x, waterPlacementYIndex, Smoke)
            ) {
              grid.place(x, waterPlacementYIndex, Water);
            }
          }
        }
      }

      class Wood extends Solid {
        constructor() {
          super();
          this.friction = 1;
          this.onfire = false;
        }

        is_flammable() {
          return true;
        }

        update(x, y, deltaMilliSeconds) {
          this.update_flame(x, y, deltaMilliSeconds);
        }

        color() {
          // TODO change color when on fire
          return [55, 25, 0];
        }
      }

      class Fire extends Solid {
        constructor() {
          super();
          this.friction = 1;
          this.temperature = 700.0;
        }

        update(x, y, deltaMilliSeconds) {
          this.lifetime -= deltaMilliSeconds;

          // TODO should there only be smoke when something is burning
          for (var i = 0; i < 8; i++) {
            if (Math.random() < 0.95) continue;
            if (place_if_empty(x + dx[i], y + dy[i], Smoke)) {
              break;
            }
          }

          for (var i = 0; i < 8; i++) {
            if (grid.is_flammable(x + dx[i], y + dy[i])) {
              if (Math.random() > 0.9) {
                grid.at(x + dx[i], y + dy[i]).onfire = true;
              }
            }
          }
        }

        color() {
          let alpha = Math.floor((this.lifetime / LIFETIME) * 255);
          return [255, 0, 0, alpha];
        }
      }

      class Smoke extends Gas {
        constructor() {
          super();
        }
        color() {
          if (Math.random() < 0.33) {
            return [20, 20, 20, 128];
          } else if (Math.random() < 0.66) {
            return [40, 40, 40, 128];
          } else {
            return [60, 60, 60, 128];
          }
        }
      }

      class Steam extends Gas {
        constructor() {
          super();
        }
        color() {
          if (Math.random() < 0.33) {
            return [120, 120, 120, 128];
          } else if (Math.random() < 0.66) {
            return [140, 140, 140, 128];
          } else {
            return [160, 160, 160, 128];
          }
        }
      }

      class MovableSolid extends Solid {
        constructor() {
          super();
          this.friction = 1;
        }

        update(x, y, deltaMilliSeconds) {
          this.updated = true;
          if (grid.empty(x, y + 1)) {
            grid.swap(x, y, x, y + 1);
          } else if (this.friction < 0.5 && grid.empty(x - 1, y + 1)) {
            grid.swap(x, y, x - 1, y + 1);
          } else if (this.friction < 0.5 && grid.empty(x + 1, y + 1)) {
            grid.swap(x, y, x + 1, y + 1);
          } else if (grid.islessdense(x, y + 1, this.density)) {
            grid.swap(x, y, x, y + 1);
          } else if (
            this.friction < 0.5 &&
            grid.islessdense(x, y + 1, this.density)
          ) {
            grid.swap(x, y, x - 1, y + 1);
          } else if (
            this.friction < 0.5 &&
            grid.islessdense(x + 1, y + 1, this.density)
          ) {
            grid.swap(x, y, x + 1, y + 1);
          }
        }
      }

      class Flea extends Liquid {
        constructor() {
          super();
          this.friction = 1;
          this.density = 1;
        }

        update(x, y, deltaMilliSeconds) {
          super.update(x, y, deltaMilliSeconds);
          var empty = 0;
          for (var i = 0; i < 8; i++) {
            if (grid.empty(x + dx[i], y + dy[i])) {
              empty += 1;
            }
          }

          if (empty <= 2) {
            this.lifetime -= 10;
          }
        }

        color() {
          return [52, 30, 17];
        }
      }

      class Dirt extends MovableSolid {
        constructor() {
          super();
          this.friction = 1;
        }
        color() {
          return [52, 30, 17];
        }
      }

      class Sand extends MovableSolid {
        constructor() {
          super();
          this.friction = 0;
        }
        color() {
          return [189, 183, 107];
        }
      }

      class Torch extends Solid {
        color() {
          return [255, 165, 10];
        }
        update(x, y, deltaMilliSeconds) {
          if (Math.random() > 0.9) {
            let firePlacementYIndex = y - 1;
            // Find the next non-cloud tile vertically below
            while (
              firePlacementYIndex >= 0 &&
              grid.matching(x, firePlacementYIndex, Fire)
            ) {
              firePlacementYIndex--;
            }
            if (
              grid.matching(x, firePlacementYIndex, Empty) ||
              grid.matching(x, firePlacementYIndex, Gas)
            ) {
              grid.place(x, firePlacementYIndex, Fire);
            }
          }
        }
      }

      class Ice extends MovableSolid {
        constructor() {
          super();
          this.density = 0.917;
          this.friction = 0.5;
          this.temperature = -10.0;
        }

        color() {
          return [173, 216, 230];
        }
        update(x, y, deltaMilliSeconds) {
          super.update(x, y, deltaMilliSeconds);
          this.updateTemperature(x, y, deltaMilliSeconds);
          if (this.temperature > 1.0) {
            this.lifetime -= this.temperature * deltaMilliSeconds;
          }
          if (this.lifetime < 1.0) {
            grid.place(x, y, Water);
          }
        }
      }

      /////// /////// /////// /////// ///////
      ///////      End Materials      ///////
      /////// /////// /////// /////// ///////
    </script>
    <script>
      class Grid {
        constructor(w, h) {
          this.w = w;
          this.h = h;
          this.data = new Array(w * h);
          for (var i = 0; i < w * h; i++) {
            this.data[i] = new Empty();
          }
        }
        xy(x, y) {
          return y * this.w + x;
        }
        at(x, y) {
          return this.data[this.xy(x, y)];
        }
        in(x, y) {
          return x >= 0 && y >= 0 && x < this.w && y < this.h;
        }

        place(x, y, material) {
          if (!this.in(x, y)) return;
          x = Math.floor(x);
          y = Math.floor(y);
          this.data[this.xy(x, y)] = objOfType(material);
        }

        clear(x, y) {
          if (this.in(x, y)) this.data[this.xy(x, y)] = new Empty();
        }

        empty(x, y) {
          if (!this.in(x, y)) return false;
          return this.at(x, y) instanceof Empty;
        }

        matching(x, y, type) {
          if (!this.in(x, y)) return false;
          return this.at(x, y) instanceof type;
        }

        islessdense(x, y, den) {
          if (!this.in(x, y)) return false;
          return this.at(x, y).density < den;
        }

        is_flammable(x, y) {
          if (!this.in(x, y)) return false;
          return this.at(x, y).is_flammable();
        }

        swap(x, y, a, b) {
          if (!this.in(x, y)) return false;
          if (!this.in(a, b)) return false;
          let me = this.at(x, y);
          let them = this.at(a, b);
          this.data[this.xy(x, y)] = them;
          this.data[this.xy(a, b)] = me;
        }
      }

      function setSelectedMaterial(mat) {
        selectedMaterial = mat;
        dropdown.selectedIndex = Object.keys(Material).indexOf(mat);
      }

      function update(progress) {
        setSelectedMaterial(Object.keys(Material)[dropdown.selectedIndex]);

        for (var i = 0; i < grid_w; i++) {
          for (var j = 0; j < grid_h; j++) {
            let x = grid.at(i, j);
            if (x.updated) continue;
            x.update(i, j, progress);
          }
        }
        for (var i = 0; i < grid_w; i++) {
          for (var j = 0; j < grid_h; j++) {
            let x = grid.at(i, j);
            x.updated = false;
            if (x.lifetime < 0) {
              grid.place(i, j, Material.Empty);
            }
          }
        }

        if (mouse) {
          place_circle(mp[0], mp[1], penRadius - 1, selectedMaterial);
        }
      }

      function draw() {
        var image = ctx.getImageData(0, 0, grid_w, grid_h);
        var data = image.data;
        var d = 0;
        for (var i = 0; i < grid.data.length; i++) {
          var [r, g, b, a] = grid.data[i].color();
          data[d + 0] = r;
          data[d + 1] = g;
          data[d + 2] = b;
          data[d + 3] = a ?? 255;
          d += 4;
        }
        ctx.clearRect(0, 0, grid_w, grid_h);
        ctx.putImageData(image, 0, 0);

        //
        outctx.clearRect(0, 0, grid_w, grid_h);
        outctx.drawImage(canvas, 0, 0);
      }

      var lastRender = 0;
      function loop(timestamp) {
        var progress = timestamp - lastRender;
        if (progress > 10) {
          lastRender = timestamp;
          update(progress);
        }
        draw();
        frame++;
        if (frame < 1000000) {
          window.requestAnimationFrame(loop);
        }
      }

      let scale = 10;

      let iw = window.innerWidth;
      let ih = window.innerHeight - 50;

      let canvas = document.getElementById("src");
      canvas.width = iw / scale;
      canvas.height = ih / scale;
      let ctx = canvas.getContext("2d");
      canvas.style.display = "none";

      let grid_w = canvas.width;
      let grid_h = canvas.height;

      let output = document.getElementById("dst");
      output.width = iw;
      output.height = ih;
      let outctx = output.getContext("2d");
      outctx.imageSmoothingEnabled = false;
      outctx.scale(scale, scale);

      let frame = 0;
      let grid = new Grid(grid_w, grid_h);

      let penRadius = 2;
      let selectedMaterial = Material.Sand;

      // a b c
      // d e f
      // g h i
      //           a   b   c   d  f   g  h  i  e
      const dx = [-1, 0, 1, -1, 1, -1, 0, 1, 0];
      const dy = [-1, -1, -1, 0, 0, 1, 1, 1, 0];

      let mouse = false;
      let mp = [0, 0];
      output.addEventListener("mousedown", function (e) {
        mouse = true;
      });

      output.addEventListener("mousemove", function (e) {
        const rect = output.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        mp = [Math.floor(x / scale), Math.floor(y / scale)];
      });

      output.addEventListener("mouseup", function (e) {
        mouse = false;
      });

      window.addEventListener(
        "keydown",
        (event) => {
          let key = event.key;
          if (key === "s") setSelectedMaterial(Material.Sand);
          if (key === "w") setSelectedMaterial(Material.Water);
          if (key === "e") setSelectedMaterial(Material.Empty);
          if (key === "b") setSelectedMaterial(Material.Blackhole);
          if (key === "t") setSelectedMaterial(Material.Wood);
          if (key === "c") setSelectedMaterial(Material.Cloud);
          if (key === "f") setSelectedMaterial(Material.Fire);
          if (key === "d") setSelectedMaterial(Material.Dirt);
          if (key === "a") setSelectedMaterial(Material.Oil);
          if (key === "i") setSelectedMaterial(Material.Ice);
          if (key === "1") penSize(1);
          if (key === "2") penSize(-1);
        },
        false
      );

      let dropdown = document.getElementById("tool");
      {
        const types = Object.keys(Material);
        for (var type of types) {
          let option = document.createElement("option");
          option.text = type;
          dropdown.add(option);
        }
      }

      let radiusLabel = document.getElementById("penRadius");
      let plus = document.getElementById("plus");
      let minus = document.getElementById("minus");

      function penSize(x) {
        penRadius = Math.max(0, Math.min(grid_w, penRadius + x));
        radiusLabel.innerHTML = penRadius;
      }

      plus.addEventListener("click", (e) => {
        penSize(1);
      });
      minus.addEventListener("click", (e) => {
        penSize(-1);
      });

      window.requestAnimationFrame(loop);
    </script>
  </body>
</html>
